-- Migration: Create pastes table with Gatekeeper security model
-- Description: Sets up the core pastes table with RLS policies that enforce
--              the Gatekeeper pattern (only service_role can INSERT)

-- Create the pastes table
create table if not exists public.pastes (
  -- Primary key
  id bigint generated by default as identity primary key,

  -- URL identifier (generated via Redis INCR + Hashids)
  slug text not null unique,

  -- Content storage (small vs large file handling)
  content text,                   -- For content <100KB
  storage_path text,              -- For content >100KB stored in object storage
  language text default 'text',

  -- User tracking
  user_id uuid references auth.users on delete set null,
  ip_hash text,                   -- SHA-256 hash of IP for abuse tracking

  -- Timestamps & Expiration
  created_at timestamptz not null default now(),
  expires_at timestamptz,         -- NULL = "Never Expire" (auth users only)

  -- Views counter (optional - for analytics)
  view_count bigint default 0,

  -- Business Logic Constraint: Anonymous users MUST have expiration
  constraint check_anonymous_expiration check (
    (user_id is not null) OR (expires_at is not null)
  ),

  -- Ensure either content or storage_path is set, but not both
  constraint check_content_or_storage check (
    (content is not null and storage_path is null) OR
    (content is null and storage_path is not null)
  )
);

-- Indexes for performance
create index if not exists idx_pastes_slug on public.pastes(slug);
create index if not exists idx_pastes_user_id on public.pastes(user_id);
create index if not exists idx_pastes_expires_at on public.pastes(expires_at) where expires_at is not null;
create index if not exists idx_pastes_created_at on public.pastes(created_at desc);
create index if not exists idx_pastes_ip_hash on public.pastes(ip_hash);

-- Enable Row Level Security
alter table public.pastes enable row level security;

-- RLS Policy: Anyone can READ pastes that haven't expired
create policy "Anyone can view non-expired pastes"
  on public.pastes
  for select
  using (
    expires_at is null OR expires_at > now()
  );

-- RLS Policy: ONLY service_role can INSERT (The Gatekeeper Pattern)
-- This prevents clients from bypassing rate limits by inserting directly
create policy "Only service_role can insert pastes"
  on public.pastes
  for insert
  with check (false);  -- No client can insert; only service_role bypasses RLS

-- RLS Policy: Users can DELETE their own pastes (or expired ones can be pruned)
create policy "Users can delete their own pastes"
  on public.pastes
  for delete
  using (
    auth.uid() = user_id
  );

-- Function to auto-delete expired pastes (called by pg_cron)
create or replace function public.delete_expired_pastes()
returns void
language plpgsql
security definer
as $$
begin
  delete from public.pastes
  where expires_at is not null
    and expires_at < now();
end;
$$;

-- Grant execute permission to service_role
grant execute on function public.delete_expired_pastes() to service_role;

-- Comments for documentation
comment on table public.pastes is 'Stores paste metadata. Large files (>100KB) are stored in object storage.';
comment on column public.pastes.slug is 'URL-safe identifier generated via Redis INCR + Hashids';
comment on column public.pastes.ip_hash is 'SHA-256 hash of creator IP for rate limiting and abuse prevention';
comment on column public.pastes.expires_at is 'NULL means never expire (authenticated users only)';
comment on constraint check_anonymous_expiration on public.pastes is 'Enforces that anonymous users cannot create pastes';
