# CLAUDE.md

This file provides guidance to LLM agents when working with code in this repository.

## Project Overview

This is a **Scalable AI Pastebin** - a read-heavy code sharing platform built with Next.js 16+ that prioritizes instant retrieval speed, strict security via a "Gatekeeper" pattern, and event-driven AI analysis.

### Core Philosophies

1. **Async-First**: User interactions (create/view) are decoupled from heavy processing (AI). The interface must remain snappy regardless of load.
2. **The Gatekeeper**: The database is locked to the outside world. All writes pass through the application layer to enforce business logic and rate limiting.
3. **Deterministic IDs**: Use Redis atomic increment + Hashids for collision-free ID generation (no random strings).

## Architecture Layers

| Layer | Technology | Role | Responsibility |
|-------|-----------|------|----------------|
| Edge | Next.js 16+ | The Receptionist | Routing, UI, Edge Middleware for security/IP blocking |
| Speed | Upstash Redis | The Bouncer | Atomic ID generation, rate limiting, hot cache for viral pastes |
| Truth | Supabase (PostgreSQL) | The Vault | Persistent storage with Row Level Security (RLS) |
| Event | Webhooks | The Broadcaster | Emit events to trigger AI workers/integrations |

## Development Commands

```bash
# Start development server
pnpm dev

# Build for production
pnpm build

# Start production server
pnpm start

# Run linting
pnpm lint
```

## Path Aliases

The project uses TypeScript path aliases configured in `tsconfig.json`:

- `@/*` - Root directory
- `@/components` - UI components
- `@/lib` - Utility libraries
- `@/hooks` - React hooks
- `@/components/ui` - shadcn/ui components

## UI Component System

This project uses **shadcn/ui** (Radix Mira style) with:
- Tailwind CSS v4 (with CSS variables for theming)
- Lucide React for icons
- Base color: neutral
- Theme: supports dark mode
- CSS location: `app/globals.css`

To add new shadcn components:
```bash
npx shadcn@latest add <component-name>
```

## Critical Patterns

### 1. The Gatekeeper Pattern (Database Security)

**Problem**: Prevent users from bypassing rate limits by calling Supabase directly from the browser.

**Solution**:
- Database RLS Policy: `INSERT` allowed only for `service_role`
- Client-side insert permissions are fully revoked
- All writes must go through Next.js Server Actions

**Implementation**:
```typescript
// Server Action (app/actions/createPaste.ts)
import { createClient } from '@supabase/supabase-js'

// Use service_role to bypass RLS
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY! // Admin key
)

// Only this server-side code can write to DB
await supabase.from('pastes').insert({ ... })
```

### 2. Collision-Free ID Generation

**Never** use random strings or UUIDs for paste slugs. Always use:

1. Redis atomic increment (`INCR`) for unique integer
2. Hashids library to obfuscate into a short string (e.g., `100001` â†’ `x9Lk2`)

**Benefits**:
- Zero collisions (mathematically guaranteed)
- No database lookups during generation
- Unguessable URLs
- Scales to 56.8 billion unique URLs (6 chars, base62)

### 3. Cache-Aside Pattern for Reads

```typescript
// 1. Check Redis cache first
const cached = await redis.get(`paste:${slug}`)
if (cached) return cached // <5ms response

// 2. On miss, query Supabase
const paste = await supabase.from('pastes').select('*').eq('slug', slug).single()

// 3. Store in cache for next time
await redis.set(`paste:${slug}`, paste, { ex: 3600 })
```

### 4. Lazy-Loading AI Results

The code must render immediately. AI explanations load separately to avoid blocking the user:

```typescript
// Page renders paste content instantly
<PasteView content={paste.content} />

// AI component loads asynchronously
<Suspense fallback={<Skeleton />}>
  <AIExplanation pasteId={paste.id} />
</Suspense>
```

## Database Schema

```sql
create table public.pastes (
  id bigint generated by default as identity primary key,
  slug text not null unique,      -- The Hashid
  content text,                   -- Small content (<100KB)
  storage_path text,              -- Large content (>100KB) stored in S3
  language text default 'text',

  user_id uuid references auth.users on delete set null,
  ip_hash text,                   -- For abuse tracking

  created_at timestamptz default now(),
  expires_at timestamptz,         -- Nullable = "Forever"

  -- CRITICAL: Anonymous users must have expiration
  constraint check_anonymous_expiration check (
    (user_id is not null) OR (expires_at is not null)
  )
);
```

## Business Logic Constraints

### Expiration Rules
- **Anonymous users**: Must have expiration (max 7 days)
- **Authenticated users**: Can set "Never Expire" (expires_at = null)
- **Enforcement**: Database constraint + Server Action validation

### Rate Limiting
- Check IP against Redis before any write
- Default: 5 requests/minute per IP
- Implement in Edge Middleware or Server Action

### Large File Handling
- Content >100KB must go to object storage (S3)
- Store only `storage_path` in Postgres
- Keeps database performant for queries

## Event-Driven Architecture

When a paste is created, emit a standardized event:

```typescript
// After successful insert
await fetch(process.env.WEBHOOK_URL, {
  method: 'POST',
  body: JSON.stringify({
    event: 'paste.created',
    data: {
      id: paste.id,
      slug: paste.slug,
      language: paste.language,
      user_id: paste.user_id
    }
  })
})
```

This allows:
- AI workers to process asynchronously
- Future user webhooks (e.g., "Post to Slack")
- Security scanning
- Analytics

## Data Cleanup Strategy

Use `pg_cron` to prune expired pastes:

```sql
-- Run hourly
SELECT cron.schedule(
  'delete-expired-pastes',
  '0 * * * *',
  'DELETE FROM pastes WHERE expires_at < NOW()'
);
```

The anonymous user constraint ensures junk data always expires, preventing database bloat.

## Next.js App Router Structure

- `app/layout.tsx` - Root layout with Geist fonts
- `app/page.tsx` - Homepage
- `app/globals.css` - Tailwind styles + CSS variables
- Server Actions should live in `app/actions/` (create if needed)
- API routes (if needed) in `app/api/`

## Environment Variables Required

```bash
# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=  # For Gatekeeper writes

# Redis (Upstash)
UPSTASH_REDIS_URL=
UPSTASH_REDIS_TOKEN=

# Hashids
HASHIDS_SALT=  # Secret for ID obfuscation

# Event Bus
WEBHOOK_URL=  # For paste.created events
```

## Key Implementation Guidelines

1. **Never expose service_role key to client**: Only use in Server Actions
2. **Always rate limit before database operations**: Check Redis first
3. **Use Server Actions for all mutations**: Client should never call Supabase directly
4. **Implement optimistic UI updates**: Don't wait for confirmations
5. **Partition AI processing**: Not every paste needs AI analysis (cost control)
6. **Use TypeScript strict mode**: Already enabled in tsconfig.json
